#name : Create a LuaOO C file
# --

/*
  \`Object model' inspired by:
  http://lua-users.org/wiki/UserDataWithPointerExample
  http://lua-users.org/wiki/ObjectProperties
*/

#include <stdlib.h>
#include <curses.h>
#include "lua/lua_utils.h"
#include "ui/ui_utils.h"
#include "ui/${1:`(file-name-nondirectory (file-name-sans-extension (buffer-file-name)))`}.h"

/* Constructor */
static const luaL_reg	${2:lui}_$1_class_methods[]=
  {
    {"new",		$2_new_$1},
    {NULL,		NULL}
  };

/*
  Create a new $1
  ${1:$(capitalize text)}.new()
*/
int		$2_new_$1(lua_State *L)
{
$0
}

/* Getters */

/* this structure map members to getters() */
static const t_index_wrap	$2_$1_get_methods[]=
  {
    {NULL,			NULL, 0}
  };


/*
  This function handle the \`__index' field.

  Stack:
  1: the instance table
  2: the accessed key
*/
int		$2_$1_index(lua_State *L)
{
  const char	*key = luaL_checkstring(L, 2);

  lua_getmetatable(L, 1);
  lua_getfield(L, -1, key);

  /* Either key is name of a method in the metatable */
  if (!lua_isnil(L, -1))
    return 1;

  /* ... or its a field access, so recall as self.get(self, value). */
  lua_settop(L, 2);   /* restore the initial call state, arg1, arg2 */

  return lua_oo_accessors(L, $2_$1_get_methods);
}



/* Setters */

/* this structure map members to setters() */
static const t_index_wrap	$2_$1_set_methods[]=
  {
    {NULL,			NULL, 0}
  };


/*
  $1.key = true/false
  or
  $1["key"] = true/false

  Stack:
  1: the instance table
  2: the accessed key
  3: the value to set
*/
int		$2_$1_newindex(lua_State *L)
{
  return lua_oo_accessors(L, $2_$1_set_methods);
}

/* Utils */

static const luaL_reg $2_$1_instance_methods[]=
  {
    {"__index",		$2_$1_index},
    {"__newindex",	$2_$1_newindex},
    {"__gc",		$2_destroy_$1},
    {"__tostring",	$2_$1_tostring},
    {NULL,		NULL}
  };


/*
  Map all the fields of the class/object.
*/
int		$2_$1_register(lua_State *L)
{
  luaL_register(L, ${3:`(upcase (file-name-nondirectory (file-name-sans-extension (buffer-file-name))))`}_CLASS, $2_$1_class_methods);
  luaL_newmetatable(L, $3_INST);
  luaL_register(L, NULL, $2_$1_instance_methods);

  /* __METATABLE */
  /*
    __metatable is for protecting metatables. If you do not want a program
    to change the contents of a metatable, you set its __metatable field.
    With that, the program cannot access the metatable (and therefore cannot
    change it).
  */
  lua_pushliteral(L, "__metatable");
  lua_pushvalue(L, -2);		/* dup methods table*/
  lua_rawset(L, -3);		/* metatable.__metatable = metatable */


  /* __INDEX */
  /*
    When it is a function, Lua calls it with the table and the absent
    key as its arguments.
    When it is a table, Lua redoes the access in that table.
  */


  lua_pop(L, 1);		/* drop metatable */
  return 0;
}



/* Methods  */

/*
  tostring($1), $1.__tostring
  just print the type and pointer address of the ${1:$(capitalize text)}
*/
int		$2_$1_tostring(lua_State *L)
{
  lua_pushfstring(L, "$1: %p", lua_touserdata(L, 1));
  return 1;
}



/* Destructor */

/*
  $1.__gc
  destroy the $1

  Stack:
  1: the instance table
  2: the accessed key
*/
int		$2_destroy_$1(lua_State *L)
{
  return 0;
}
